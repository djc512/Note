1.给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。
private int[] arr = {1, 4, 2, 1, 2};
public int getNum() {
	int result = 0;
	for (int i = 0; i < arr.length; i++)
		result ^= arr[i];
	return result;
}
1.使用异或的操作进行处理

异或操作：
	1.转换成二进制，相同为0不同为1  如：001^100 = 111;
	2.交换律	如：a^b^c = a^c^b = c^b^a 
	3.结合律	如：a^(b^c) = (a^b)^c
	4.对于任何数都有	a^a = 0	  a^0 = a
	5.自反性	a^b^b = a^0 = a;  注：不分前后，同级运算a^b^b 可以先运行b^b然后结果再与a^运算

2.给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。
不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。

class Solution {
    public int removeDuplicates(int[] nums) {
        int num = 0;
        for (int i = 0; i < nums.length; i++) {
            
            if (nums[num] != nums[i]) {
                num++;
                nums[num] = nums[i];
            }
        }
        return num + 1;
    }
}

1.判断当前与下一位是否一样，如果不一样就替换成下一个
2.数组只需替换当前下标对应的值


3.给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。
设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。
注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

int[] prices = {7,1,5,3,6,4};
public int maxProfit() {
	int max = 0;
	int size = prices.length;
	for (int i = 0; i < size - 1; ++i)
		if (prices[i] < prices[i + 1])
			max += prices[i + 1] - prices[i];
	return max;
}

1.将数据画在表上最直观，可以看出来要想利益最大，最好的办法就是只要有收益就卖出
2.只需处理下当一个元素大于前一个元素的差，然后相加即可

